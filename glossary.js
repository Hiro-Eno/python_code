// glossaryファイル Python_Code
`use strict`
const glossary = [
{target:`abs()`, content:`絶対値を返す。<br>***(-5) → 5`},
{target:`aiter()`, content:`非同期イテレータ（要素のシーケンスを順番に取り出すためのオブジェクト）を生成。<br>ait = ***(iterable); await anext(ait)`},
{target:`all()`, content:`全てが真ならTrue。<br>***([True, False, True]) → False`},
{target:`anext()`, content:`非同期イテレータ（要素のシーケンスを順番に取り出すためのオブジェクト）から次を返す。<br>ait = aiter(iterable); await ***(ait)`},
{target:`any()`, content:`一つでも真ならTrue。<br>***([False, True, False]) → True`},
{target:`ascii()`, content:`ASCIIエスケープ文字列。<br>***('あ') → '\\u3042'`},
{target:`bin()`, content:`2進数文字列を返す。<br>***(10) → '0b1010'`},
{target:`bool()`, content:`真偽値を返す。<br>***(0) → False`},
{target:`breakpoint()`, content:`デバッグポイント。その行でプログラムの実行が一時停止し、対話型のデバッガが起動。<br>***()`},
{target:`bytearray()`, content:`バイト配列を返す。<br>***(b'hello')`},
{target:`bytes()`, content:`バイトオブジェクト。<br>***([65, 66, 67])`},
{target:`callable()`, content:`与えられたオブジェクトが呼び出し可能かどうかを判定。呼び出し可能ならTrue。<br>***(print) → True`},
{target:`chr()`, content:`Unicode文字を返す。<br>***(8364) → '€'`},
{target:`classmethod()`, content:`クラスメソッド（class method）を定義するためのデコレータ。クラスメソッドは、クラスに紐づくメソッドであり、そのメソッドが属するクラス自体を第一引数として受け取る。通常、クラスメソッドはclsという名前の引数を使用して、クラス自体にアクセス。<br>***(func)`},
{target:`compile()`, content:`文字列からコードオブジェクトを生成。文字列として表現されたPythonのコードを実行可能なコードオブジェクトに変換。<br>***('print('Hello')', '', 'exec')`},
{target:`complex()`, content:`複素数を生成。<br>***(1, 2) → (1+2j)`},
{target:`delattr()`, content:`属性を削除。<br>***(obj, 'attr')`},
{target:`dict()`, content:`辞書を生成。<br>***(name='John', age=30)`},
{target:`dir()`, content:`オブジェクトの属性リスト。<br>***(obj)`},
{target:`divmod()`, content:`商と余りを返す。<br>***(10, 3) → (3, 1)`},
{target:`enumerate()`, content:`与えられたイテラブル（例えば、リストやタプルなど）の要素を順番に取り出し、それぞれの要素と対応するインデックス（通常は0から始まる整数）のペアを返す列挙オブジェクトを生成。<br>***(['a', 'b', 'c'])→[(0, 'a'), (1, 'b'), (2, 'c')]`},
{target:`eval()`, content:`式を評価。与えられた文字列が有効なPythonの式であれば、その式を評価してその結果を返す。<br>***('2 + 3') → 5`},
{target:`exec()`, content:`文字列として与えられたPythonコードを実行。文字列として渡されたPythonコードは、実行時に評価され、その結果を反映。<br>***('print('Hello')')`},
{target:`filter()`, content:`条件に合致する要素をフィルタ。<br>***(lambda x: x % 2 == 0, [1, 2, 3, 4])→ [2, 4]`},
{target:`float()`, content:`浮動小数点数を返す。<br>***(3) → 3.0`},
{target:`format()`, content:`書式化された文字列を返す。<br>***(0.5, '%')`},
{target:`for`, content:`シーケンス（リスト、タプル、文字列など）内の各要素に対して反復処理を行うための制御構造<br>*** i in range(5):<br>   print(i)`},
{target:`frozenset()`, content:`不変な集合を生成。不変な集合は、一度作成されると変更できない（immutable）性質を持っており、通常の集合と異なり、要素の追加や削除ができない。<br>***([1, 2, 3])`},
{target:`getattr()`, content:`オブジェクトから指定された属性の値を取得。<br>***(obj, 'attr')`},
{target:`globals()`, content:`現在のグローバルシンボルテーブル（変数や関数が格納される場所）を返す。グローバルシンボルテーブルには、プログラム全体でアクセス可能な変数や関数を格納。<br>***()`},
{target:`hasattr()`, content:`指定されたオブジェクトが指定された属性を持っているかどうかを判定。属性があればTrue。<br>***(obj, 'attr') → True`},
{target:`hash()`, content:`与えられたオブジェクトのハッシュ値を返す。ハッシュ値は、同じ内容のオブジェクトに対して同じ値を返し、異なる内容のオブジェクトに対しては異なる値を返す。<br>***('hello')`},
{target:`help()`, content:`指定されたオブジェクトやモジュールに関するヘルプ情報を表示。<br>***(str)`},
{target:`hex()`, content:`16進数文字列を返す。<br>***(255) → '0xff'`},
{target:`id()`, content:`与えられたオブジェクトの一意の識別子（identity）を返す。オブジェクトの識別子は、そのオブジェクトがメモリ上でどの位置に格納されているかを表す。<br>***(obj)`},
{target:`if`, content:`条件に基づいてプログラムの特定の部分を実行するための制御構造<br>** y > 10:<br>実行1<br>elif y > 5:<br>実行2<br>else:実行3<br>三項演算子 x = 真の場合の値 *** 条件 else 偽の場合の値`},
{target:`import`, content:`Pythonで外部のモジュールを読み込むための構文。<br>*** math `},
{target:`input()`, content:`ユーザーに対してプロンプトを表示し、ユーザーがキーボードから入力した値を文字列として受け取る。<br>***('Enter your name: ')`},
{target:`int()`, content:`整数を返す。<br>***(3.14) → 3`},
{target:`isinstance()`, content:`指定されたオブジェクトが指定されたクラスまたはクラスのタプルのいずれかのインスタンスである場合にTrueを返す。第一引数には対象のオブジェクト (obj) を指定し、第二引数にはクラスまたはクラスのタプルを指定。<br>***(obj, int) → True`},
{target:`issubclass()`, content:`指定されたクラスが指定されたクラスまたはクラスのタプルのいずれかのサブクラスである場合にTrueを返す。第一引数には対象のクラス (SubClass) を指定し、第二引数には基底となるクラス (BaseClass) または基底クラスのタプルを指定。<br>***(SubClass, BaseClass) → True`},
{target:`iter()`, content:`指定されたイテラブル（iterable）から新しいイテレータ（iterator）を生成。イテレータは、next()関数を使って順番に要素にアクセスすることができるオブジェクト。<br>***(iterable)`},
{target:`len()`, content:`要素数または長さを返す。<br>***([1, 2, 3]) → 3`},
{target:`list()`, content:`リストを生成。<br>***((1, 2, 3))→[1, 2, 3]`},
{target:`locals()`, content:`現在のローカルスコープにおけるシンボルテーブルを辞書として返す。ローカルスコープは、関数やメソッドの中で定義された変数や関数が存在するスコープ<br>***()`},
{target:`map()`, content:`指定された関数をイテラブルの各要素に適用して、その結果からなるイテレータを生成。<br>***(lambda x: x*2, [1, 2, 3])→[2, 4, 6]`},
{target:`max()`, content:`最大の要素を返す。<br>***(4, 7, 2) → 7`},
{target:`memoryview()`, content:`指定されたバッファプロトコルに対するビューを提供。バッファプロトコルは、データのメモリ上のバッファを効率的に共有するためのプロトコル。<br>***(b'hello')`},
{target:`min()`, content:`最小の要素を返す。<br>***(4, 7, 2) → 2`},
{target:`next()`, content:`次の要素を返す。<br>***(iter([1, 2, 3]))`},
{target:`object()`, content:`新しい空のオブジェクトを生成する組み込み関数です。この関数は引数を取らず、新しいオブジェクトを返す。<br>***()`},
{target:`oct()`, content:`8進数文字列を返す。<br>***(8) → '0o10'`},
{target:`open()`, content:`指定されたファイルを開いて、対応するファイルオブジェクトを返す。ファイルオブジェクトを使用することで、ファイルからデータを読み取る（読み込む）、データを書き込む、またはファイルの内容を変更するなどの操作が可能。'r': 読み取りモード（デフォルト）。'w': 書き込みモード（既存の内容は破棄される）。'a': 追記モード（既存の内容の後に書き込む）。'b': バイナリモード（バイナリファイルを扱う）。<br>***('file.txt', 'r') as file: ...`},
{target:`ord()`, content:`Unicode文字のコードポイント。<br>***('A') → 65`},
{target:`pow()`, content:`べき乗を返す。<br>***(2, 3) → 8`},
{target:`print()`, content:`データを出力。<br>***('Hello, World!')`},
{target:`property()`, content:`プロパティを生成。クラスの属性に対してゲッター（getter）、セッター（setter）、デリーター（deleter）を指定するためのデコレータを生成。デコレータとして使用され、アトリビュートにアクセスする際に特定のメソッドを呼び出す。<br>@***; def prop(self): ...`},
{target:`range()`, content:`範囲の数値を返す。<br>***(5) → [0, 1, 2, 3, 4]<br>***(start, stop, step)`},
{target:`repr()`, content:`指定されたオブジェクトをその概要な文字列表現（representation）に変換。デバッグやログ出力などでオブジェクトの内容を人が読みやすい形式で表示する際に利用。<br>***(obj)`},
{target:`reversed()`, content:`指定されたシーケンス（リスト、タプル、文字列など）の逆順のイテレータを返す。<br>list(***([1, 2, 3]))→ [3, 2, 1]`},
{target:`round()`, content:`四捨五入した値を返す。<br>***(3.14159, 2) → 3.14`},
{target:`set()`, content:`指定されたイテラブルから集合を生成。集合は重複のない要素の組み合わせであり、順序は保持されない。<br>***([1, 2, 3])→{1, 2, 3}`},
{target:`setattr()`, content:`指定されたオブジェクトの属性に新しい値を設定。オブジェクトの属性を動的に変更する際に使用。obj: 属性を変更する対象のオブジェクト。'attr': 変更する属性の名前。value: 新しい属性の値。<br>***(obj, 'attr', value)`},
{target:`slice()`, content:`スライスオブジェクトを返す。シーケンス（リスト、タプル、文字列など）から特定の範囲の要素を抽出<br>***(1, 4)→[1, 2, 3]<br>***(start, stop, step)`},
{target:`sorted()`, content:`指定されたシーケンス（リスト、タプル、文字列など）を昇順にソートした新しいリストを返す。元のシーケンスは変更されず、新しいリストを作成。<br>***([3, 1, 4, 1, 5, 9, 2])→[1, 1, 2, 3, 4, 5, 9]<br>***(iterable, key=None, reverse=False)`},
{target:`staticmethod()`, content:`静的メソッドを定義するためのデコレータを生成。静的メソッドは、クラスのインスタンス化なしにクラス自体から直接呼び出すことができるメソッド。<br>@***; def static_method(): ...`},
{target:`str()`, content:`文字列を返す。<br>***(42) → '42'`},
{target:`sum()`, content:`合計を返す。<br>***([1, 2, 3]) → 6`},
{target:`super()`, content:`親クラス（またはスーパークラス）のメソッドや属性にアクセスする。主にサブクラス（または派生クラス）のメソッド内で親クラスのメソッドを呼び出す場合に使用。<br>***()`},
{target:`tuple()`, content:`指定されたイテラブル（リスト、文字列、タプルなど）から新しいタプルを生成。<br>***([1, 2, 3])→(1, 2, 3)`},
{target:`type()`, content:`オブジェクトの型を返す。<br>***(obj)`},
{target:`vars()`, content:`指定されたオブジェクトのローカルなシンボルテーブル（辞書）を返す。モジュール、クラス、またはインスタンスなどのオブジェクトに対して呼び出され、そのオブジェクトのローカルスコープ内の変数や属性を含む辞書を返す。<br>***()`},
{target:`while`, content:`指定された条件がTrueである限り、一連の文を繰り返し実行するための制御構造<br>*** count < 5:<br>    print(count)<br>    count += 1`},
{target:`zip()`, content:`複数のイテラブル（リスト、タプル、など）から対応する要素をペアにしてまとめ、タプルのリストを生成。<br>list(***([1, 2, 3], ['a', 'b', 'c']))→[(1, 'a'), (2, 'b'), (3, 'c')]`},
{target:`_`, content:`ダミー変数。<br>result = ***`},
{target:`__import__()`, content:`文字列として与えられたモジュール名を用いてモジュールを動的に読み込むために使用。通常はimport文を使用する方が推奨。<br>module = ***('math')`},
{target:`dict.fromkeys()`, content:`指定されたイテラブルの要素をキーとして、全てのキーに同じ初期値（デフォルトはNone）を持つ辞書を作成。listと組合せることでユニークなリストを作成に利用可能。<br>my = ***.***(['a', 'b'])→{'a': None, 'b': None}<br>list(***.***([3, 3, 2, 1, 5, 1, 4, 2, 3]))→[3, 2, 1, 5, 4]`},
{target:`list.append()`, content:`リストの末尾に要素を追加。<br>my = [1, 2, 3]; my.***(4)→[1, 2, 3, 4]`},
{target:`list.insert()`, content:`リストの指定した位置に要素を挿入。<br>my = [1, 2, 3]; my.***(1, 5)→[1, 5, 2, 3]`},
{target:`list.extend()`, content:`イテラブルの要素をリストに追加<br>my = [1, 2, 3]; my.***([4, 5])→[1, 2, 3, 4, 5]`},
{target:`list.remove(x)`, content:`リストの指定した値と一致する最初の要素を削除<br>my = [1, 2, 3]; my.***(2)→[1, 3]`},
{target:`list.pop([i])`, content:`リストの指定した位置の要素を取り出し、削除<br>my = [1, 2, 3]; x = my.***(1)→[1, 3] (x = 2) `},
{target:`list.clear()`, content:`リストのすべての要素を削除<br>my = [1, 2, 3]; my.***()→[]`},
{target:`list.index(x)`, content:`リストの指定した値と一致する最初の要素のインデックス<br>my = [1, 2, 3]; x = my.***(2)→1 (x = 1)`},
{target:`list.count(x)`, content:`リストの指定した値と一致する要素の数を数える<br>my = [1, 2, 2, 3]; x = my.***(2)→2 (x = 2)   `},
{target:`list.sort()`, content:`リストを昇順にソート<br>my = [3, 1, 4]; my.***()→[1, 3, 4]`},
{target:`list.reverse()`, content:`リストを逆順に反転<br>my = [1, 2, 3]; my.***()→[3, 2, 1]`},
{target:`str.join()`, content:`イテラブルの文字列を連結<br>my = '-'; result = my.***(['a', 'b', 'c'])→'a-b-c'`},
{target:`pd.read_csv()`, content:`CSVファイルを読み込む。<br>df = ***.***('data.csv')`},
{target:`pd.DataFrame()`, content:`データフレームを生成。<br>df = ***.***(data)`},
{target:`df.head()`, content:`データフレームの先頭の行を表示。<br>***.***()`},
{target:`df.tail()`, content:`データフレームの末尾の行を表示。<br>***.***()`},
{target:`df.info()`, content:`データフレームの情報表示。<br>***.***()`},
{target:`df.describe()`, content:`データフレームの統計的な概要を表示。<br>***.***()`},
{target:`df.shape`, content:`データフレームの形状を表示。<br>***.***`},
{target:`df.columns`, content:`データフレームのカラム名を取得。<br>columns = ***.***`},
{target:`df['column_name']`, content:`データフレームの特定のカラムを選択。<br>column_data = df['***']`},
{target:`df['column_name'].unique()`, content:`データフレームのカラムのユニークな値を表示。<br>unique_values = df['***'].***()`},
{target:`df.isnull()`, content:`データフレームの欠損値の有無を確認。<br>***.***()`},
{target:`df.dropna()`, content:`データフレームの欠損値を含む行を削除。<br>***.***()`},
{target:`df.fillna(value)`, content:`データフレームの欠損値を指定の値で補完。<br>***.***(0)`},
{target:`df.groupby()`, content:`データフレームでグループ化して統計量を計算。<br>grouped_data = ***.***('column_name').mean()`},
{target:`df.size()`, content:`データフレーム（DataFrame）の要素の総数を取得。groupby()と組合せることで各ｸﾞﾙｰﾌﾟ内のデータ数をカウントできる。<br>df_num = pd.DataFrame(df.groupby('ID').***(), columns=['num'])`},
{target:`df.groupby().apply()`, content:`データフレームでグループごとに関数を適用。<br>result = ***.***('group_column').***(custom_function)`},
{target:`df.merge()`, content:`データフレームの結合。<br>merged_***.***(df1, df2, on='key_column')`},
{target:`df.pivot_table()`, content:`データフレームのピボットテーブルを作成。<br>pivot_table = ***.***(values='value', index='index_column', columns='column_name', aggfunc=np.mean)`},
{target:`df.plot()`, content:`Pandasライブラリを使用してデータフレーム (***.***(x='column_x', y='column_y', kind='scatter')`},
{target:`df.to_csv()`, content:`データフレームをCSVファイルに保存。<br>***.***('output.csv', index=False)`},
{target:`df.iterrows()`, content:`行ごとにイテレート（繰り返し処理）。各行はインデックスと行データ（Pandas Series）のタプルとして取得。for文等で利用。<br>for index, row in ***.***(): print(row['column'])`},
{target:`df.itertuples()`, content:`行ごとにイテレート（繰り返し処理）。namedtupleを返すため、列の名前を属性として直接アクセスでき、一般にiterrows()よりも高速。<br>for row in ***.***(): print(row.column)`},
{target:`df.apply()`, content:`データフレームの列ごとに関数を適用。<br>***.***(custom_function)`},
{target:`df.map()`, content:`データフレームでの列の各要素に関数を適用。<br>***.***(custom_function)`},
{target:`df.applymap()`, content:`データフレーム全体に関数を適用。<br>***.***(custom_function)`},
{target:`df.filter()`, content:`データフレームの特定の条件に合致する行を選択。<br>filtered_***.***(like='pattern', axis=1)`},
{target:`df.query()`, content:`データフレームの条件式に合致する行を選択。<br>filtered_***.***('column > 10')`},
{target:`df.loc[]`, content:`データフレームでラベルに基づいて行を選択。<br>selected_rows = ***.***[df['column'] > 10]`},
{target:`df.iloc[]`, content:`データフレームでインデックスに基づいて行を選択。<br>selected_rows = ***.***[0:5]`},
{target:`df.at[]`, content:`ラベルとカラム名を指定して値を取得。<br>value = ***.**[0, 'column']<br>***.**[0, 'column'] = new_value`},
{target:`df.iat[]`, content:`インデックスとカラム番号を指定して値を取得。<br>value = ***.***[0, 1]`},
{target:`pd.read_excel()`, content:`Excelファイルからデータフレームを読み込む。<br>df = ***.***('input_file.xlsx', sheet_name='Sheet1')`},
{target:`pd.ExcelWriter()`, content:`ExcelWriterオブジェクトを作成。<br>writer = ***.***('output_file.xlsx', engine='openpyxl'):`},
{target:`df.to_excel()`, content:`データフレームをExcelファイルに書き込む。<br>***.***(writer, sheet_name='Sheet1', index=False)`},
{target:`writer.sheets`, content:`ExcelWriterオブジェクトのシートを参照。<br>sheet_names = ***.***.keys()`},
{target:`writer.close()`, content:`ファイルの書き込み操作が終了した際に、ファイルを閉じるためのメソッド。<br>***.***()`},
{target:`df.to_dict()`, content:`データフレームを辞書形式に変換。<br>data_dict = ***.***(orient='records')`},
{target:`np.array()`, content:`配列を生成。<br>arr = ***.***([1, 2, 3])`},
{target:`np.tolist()`, content:`配列をリストに変換。<br>list = ***.***()`},
{target:`np.zeros()`, content:`0で初期化された配列を生成。<br>zeros_arr = ***.***((2, 3))`},
{target:`np.ones()`, content:`1で初期化された配列を生成。<br>ones_arr = ***.***((3, 3))`},
{target:`np.arange()`, content:`等差数列を生成。<br>arange_arr = ***.***(0, 10, 2)→[0, 2, 4, 6, 8]`},
{target:`np.linspace()`, content:`等分された数列を生成。<br>linspace_arr = ***.***(0, 1, 5)→[0. , 0.25, 0.5, 0.75, 1. ]`},
{target:`np.random.rand()`, content:`0から1までのランダムな数値を生成。<br>rand_arr = ***.***(3, 3)`},
{target:`np.random.randn()`, content:`標準正規分布に従うランダムな数値を生成。<br>randn_arr = ***.***(3, 3)`},
{target:`np.shape()`, content:`配列の形状を取得。<br>shape = ***.***(arr)`},
{target:`np.reshape()`, content:`配列の形状を変更。<br>reshaped_arr = ***.***(arr, (3, 1))`},
{target:`np.transpose()`, content:`配列の転置。<br>transposed_arr = ***.***(arr)`},
{target:`np.dot()`, content:`行列の積。<br>dot_product = ***.***(arr1, arr2)`},
{target:`np.sum()`, content:`合計を計算。<br>total = ***.***(arr)`},
{target:`np.mean()`, content:`平均を計算。<br>average = ***.***(arr)`},
{target:`np.max()`, content:`最大値を取得。<br>max_value = ***.***(arr)`},
{target:`np.min()`, content:`最小値を取得。<br>min_value = ***.***(arr)`},
{target:`np.save()`, content:`配列をバイナリ形式で保存。<br>***.***('array.npy', arr)`},
{target:`np.load()`, content:`バイナリ形式で保存された配列を読み込む。<br>loaded_arr = ***.***('array.npy')`},
{target:`plt.plot()`, content:`折れ線グラフを描画。<br>***.***(x_values, y_values, label='Line')`},
{target:`plt.scatter()`, content:`散布図を描画。<br>***.***(x_values, y_values, label='Points', color='red')`},
{target:`plt.bar()`, content:`棒グラフを描画。<br>***.***(x_values, height_values, label='Bars', color='blue')`},
{target:`plt.hist()`, content:`ヒストグラムを描画。<br>***.***(data, bins=20, color='green', alpha=0.7)`},
{target:`plt.xlabel()`, content:`x軸のラベルを設定。<br>***.***('X-axis Label')`},
{target:`plt.ylabel()`, content:`y軸のラベルを設定。<br>***.***('Y-axis Label')`},
{target:`plt.title()`, content:`グラフのタイトルを設定。<br>***.***('Graph Title')`},
{target:`plt.legend()`, content:`凡例を表示。<br>***.***()`},
{target:`plt.grid()`, content:`グリッド線を表示。<br>***.***(True)`},
{target:`plt.show()`, content:`グラフを表示。<br>***.***()`},
{target:`plt.savefig()`, content:`グラフを画像ファイルとして保存。<br>***.***('graph.png')`},
{target:`plt.subplot()`, content:`サブプロットを作成。<br>***.***(2, 1, 1)  # 2行1列のサブプロットの1つ目`},
{target:`plt.figure()`, content:`新しいフィギュアを作成。<br>***.***(figsize=(8, 6))`},
{target:`plt.imshow()`, content:`画像データを表示。<br>***.***(image_data, cmap='viridis')`},
{target:`plt.colorbar()`, content:`カラーバーを表示。<br>***.***()`},
{target:`plt.pie()`, content:`円グラフを描画。<br>***.***(sizes, labels=labels, autopct='%1.1f%%', startangle=90)`},
{target:`plt.axhline()`, content:`水平線を追加。<br>***.***(y=0, color='black', linestyle='--')`},
{target:`plt.axvline()`, content:`垂直線を追加。<br>***.***(x=0, color='black', linestyle='--')`},
{target:`plt.subplots()`, content:`サブプロットを一括で生成。<br>fig, axes = ***.***(nrows=2, ncols=2, figsize=(8, 6))`},
{target:`plt.tight_layout()`, content:`レイアウトの調整（重なりの解消）。<br>***.***()`},
{target:`fig.tight_layout()`, content:`レイアウトの調整（重なりの解消）。<br>***.***()`},
{target:`axes[i,j].plot()`, content:`特定のサブプロットにプロットを追加。<br>***[0, 0].***(x1, y1, label='Plot 1')`},
{target:`color`, content:`グラフの色を指定。<br>plt.plot(x, ***='blue')`},
{target:`linestyle`, content:`線のスタイルを指定。<br>plt.plot(x, ***='--')`},
{target:`marker`, content:`マーカーの種類を指定。<br>plt.plot(x, ***='o')`},
{target:`s`, content:`マーカーのサイズを指定。<br>plt.scatter(x, ***=20)`},
{target:`alpha (mat)`, content:`プロットやマーカーの透明度を指定。<br>plt.scatter(x, ***=0.5)`},
{target:`linewidth (mat)`, content:`線の太さを指定。<br>plt.plot(x, ***=2)`},
{target:`edgecolor (mat)`, content:`マーカーの枠線の色を指定。<br>plt.scatter(x, ***='black')`},
{target:`facecolor`, content:`マーカーの塗りつぶしの色を指定。<br>plt.scatter(x, ***='red')`},
{target:`label`, content:`ラベルを指定。<br>plt.plot(x, ***='Line')`},
{target:`zorder`, content:`グラフの描画順序を指定。<br>plt.scatter(x, ***=2)`},
{target:`fillstyle`, content:`マーカーの塗りつぶしのスタイルを指定。<br>plt.scatter(x, ***='left')`},
{target:`markevery`, content:`マーカーを何個おきに表示するか指定。<br>plt.plot(x, y, marker='o', ***=2)`},
{target:`default`, content:`デフォルトのMatplotlibスタイル。<br>plt.style.use('***')`},
{target:`seaborn`, content:`Seabornライクなスタイル。<br>plt.style.use('***')`},
{target:`ggplot`, content:`ggplot2ライクなスタイル。<br>plt.style.use('***')`},
{target:`fivethirtyeight`, content:`FiveThirtyEightライクなスタイル。<br>plt.style.use('***')`},
{target:`bmh`, content:`Bokehライクなスタイル。<br>plt.style.use('***')`},
{target:`dark_background`, content:`ダークバックグラウンド。<br>plt.style.use('***')`},
{target:`grayscale`, content:`グレースケールスタイル。<br>plt.style.use('***')`},
{target:`seaborn-darkgrid`, content:`Seabornダークグリッドスタイル。<br>plt.style.use('***')`},
{target:`seaborn-poster`, content:`Seabornポスタースタイル。<br>plt.style.use('***')`},
{target:`seaborn-ticks`, content:`Seabornライクな目盛り。<br>plt.style.use('***')`},
{target:`tableau-colorblind10`, content:`TableauColorBlind10スタイル。<br>plt.style.use('***')`},
{target:`sns.set()`, content:`Seabornのデフォルトスタイルを設定。<br>***.***(style='whitegrid')`},
{target:`sns.scatterplot()`, content:`散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.lineplot()`, content:`折れ線グラフを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.barplot()`, content:`棒グラフを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.histplot()`, content:`ヒストグラムを描画。<br>***.***(data=df, x='column', kde=True)`},
{target:`sns.boxplot()`, content:`箱ひげ図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.violinplot()`, content:`バイオリンプロットを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.heatmap()`, content:`ヒートマップを描画。<br>***.***(data=correlation_matrix, annot=True)`},
{target:`sns.pairplot()`, content:`変数のペアプロットを描画。<br>***.***(df, hue='category_column')`},
{target:`sns.lmplot()`, content:`回帰線を含む散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.catplot()`, content:`カテゴリカルデータのプロットを描画。<br>***.***(x='x_column', y='y_column', data=df, kind='swarm')`},
{target:`sns.jointplot()`, content:`二変数の関係を可視化。<br>***.***(x='x_column', y='y_column', data=df, kind='scatter')`},
{target:`sns.stripplot()`, content:`ストリッププロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.swarmplot()`, content:`スワームプロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.pointplot()`, content:`ポイントプロットを描画。<br>***.***(x='category_column', y='value_column', data=df)`},
{target:`sns.relplot()`, content:`関係プロットを描画。<br>***.***(x='x_column', y='y_column', hue='category_column', data=df)`},
{target:`sns.linearmodels.ols()`, content:`線形モデルをOLSで計算し、結果を可視化。<br>***.***.***('y ~ x', data=df).fit().plot()`},
{target:`sns.regplot()`, content:`線形回帰モデルとデータの散布図を描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.residplot()`, content:`回帰分析の残差を可視化。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.countplot()`, content:`カテゴリの出現回数を可視化。<br>***.***(x='category_column', data=df)`},
{target:`sns.boxenplot()`, content:`Boxenプロットを描画。<br>***.***(x='x_column', y='y_column', data=df)`},
{target:`sns.clustermap()`, content:`クラスターマップを描画。<br>***.***(data=df.corr(), annot=True)`},
{target:`sns.kdeplot()`, content:`カーネル密度推定プロットを描画。<br>***.***(data=df, x='column', fill=True)`},
{target:`sns.factorplot()`, content:`グラフをファクタープロットとして描画。<br>***.***(x='x_column', y='y_column', hue='category_column', data=df)`},
{target:`darkgrid`, content:`背景にグリッドを表示。<br>sns.set(style='***')`},
{target:`whitegrid`, content:`白い背景にグリッドを表示。<br>sns.set(style='***')`},
{target:`ticks`, content:`軸に目盛りを表示。<br>sns.set(style='***')`},
{target:`white`, content:`白い背景。<br>sns.set(style='***')`},
{target:`dark`, content:`黒い背景。<br>sns.set(style='***')`},
{target:`talk`, content:`軸のラベルが大きいスタイル。<br>sns.set_context('***')`},
{target:`paper`, content:`レポート印刷用スタイル。<br>sns.set_context('***')`},
{target:`notebook`, content:`ノートブック用スタイル。<br>sns.set_context('***')`},
{target:`poster`, content:`ポスター用スタイル。<br>sns.set_context('***')`},
{target:`hue`, content:`カテゴリ別に色分け。<br>sns.scatterplot(x='x', y='y', ***='category', data=df)`},
{target:`palette`, content:`カラーパレットを指定。<br>sns.scatterplot(x='x', y='y', ***='viridis', data=df)`},
{target:`style`, content:`マーカーのスタイルを指定。<br>sns.lineplot(x='x', y='y', ***='category', data=df)`},
{target:`markers`, content:`マーカーの種類を指定。<br>sns.scatterplot(x='x', y='y', ***=['o', 's'], data=df)`},
{target:`size`, content:`ドットのサイズを固定値で指定。<br>sns.scatterplot(x='x', y='y', ***=10, data=df)`},
{target:`sizes`, content:`ドットのサイズの範囲を指定。<br>sns.scatterplot(x='x', y='y', size='size_column', ***=(10, 200), data=df)`},
{target:`alpha (sns)`, content:`プロットやマーカーの透明度を指定。<br>sns.scatterplot(x='x', y='y', ***=0.5, data=df)`},
{target:`linewidth (sns)`, content:`線の太さを指定。<br>sns.lineplot(x='x', y='y', ***=2, data=df)`},
{target:`linestyles`, content:`線のスタイルを指定。<br>sns.lineplot(x='x', y='y', ***='--', data=df)`},
{target:`dashes`, content:`破線のパターンを指定。<br>sns.lineplot(x='x', y='y', ***=False, data=df)`},
{target:`edgecolor (sns)`, content:`マーカーの枠線の色を指定。<br>sns.scatterplot(x='x', y='y', ***='black', data=df)`},
{target:`markeredgecolor`, content:`マーカーの枠線の色を指定（style='category'時）。<br>sns.lineplot(x='x', y='y', style='category', ***='black', data=df)`},
{target:`markerfacecolor`, content:`マーカーの塗りつぶしの色を指定（style='category'時）。<br>sns.lineplot(x='x', y='y', style='category', ***='red', data=df)`},
]
